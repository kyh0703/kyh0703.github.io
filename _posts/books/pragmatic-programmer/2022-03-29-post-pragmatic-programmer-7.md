---
title: "실용주의 프로그래머 - 7(TIL)"
categories:
  - Books
tags:
  - [book, nomadcoders]
toc: true
toc_sticky: true
date: "2022-03-29 17:00"
last_modified_at: 2022-03-29T11:00:00.540Zs
---

### 범위 

~6장 동시성

### 내용

#### **요약**

- 완벽한 소프트웨어를 만들 수 없다!
- 단정적 프로그램

#### 5장. 동시성

둘 이상의 코드조각이 동시에 실행 중인것처럼 행동하는 것으로 파이버, 스레드, 프로세스 등을 사용하여 동시성 구현

> 파이버란 user-space thread인데, 하나의 쓰레드 위에 여러 개의 파이버가 협력적 멀티태스킹을 수행하는 동시성 프로그래밍 요소
>
> 고루틴과 비슷하지만 고루틴은 언어적, 파이버는 시스템적 용어이다.

공유상태가 문제인데 더 나은 모델로 `액터모델`이 있다.

액터 모델은 프로세스들이 독립적으로 수행되며 서로 데이터를 공유하지 않는다. 대신 채널을 통해 잘 정의된 단순한 의미론을 사용하여 의사소통한다.

#### 시간적 결합 깨트리기

**동시성찾기**

작업흐름을 분석하여 `활동 다이어그램` 같은 표기법을 사용해서 작업흐름을 기록하는것도 방법

**동시작업의기회**

설계를 통해 동시의 작업이 필요한 것을 찾아 넣음

**병렬작업의기회**

커다란 작업을 독립적인 부분들로 쪼개서 병렬로 각각 처리 후 결과를 합침

#### 공유 상태는 틀린 상태

공유 상태를 원자적으로 바꾸는 읽

**세마포어 및 다른 상호배제 방법**

세마포어를 사용하여 해결 할 수 있으나 모든 접근하는 주체에서 사용하여야 된다.

**리소스를 트랜잭션으로 관리하라**

리소스를 중앙으로 관리주체를 만들어 관리

**여러 리소스와 트랜잭션**

**트랜잭션이 없는 갱신**

> 불규칙한 실패는 동시성 문제인 경우가 많다.

**그 밖의 독점적인 접근**

#### 액터와 프로세스

* 액터는 자신만의 비공개 지역 상태를 가진 독립적인 가상 처리 장치다.

* 프로세스는 더 일반적인 가상 처리기로 동시성을 지원하기 위하여 구현한다.

**액터는 언제나 동시성을 띤다**

* 액터를 관리하는 것이 하나도 없다.
* 시스템이 저장하는 상태는 오직 메시지 그리고 액터의 지역 상태뿐이다. 메시지는 수신자가 읽는 것 외에는 확인할 방법이 없고, 지역 상태는 액터 바깥에서는 접근이 불가능하다.
* 모든 메시지는 일방향이다. 답장이란 개념은 없다. 메시지의 답장을 받기위해서는 콜백 주소를 넣어야한다.
* 액터는 각 메시지를 끝날 때까지 처리하고 중간에 다른 일을 하지 않는다. 즉 한 번에 하나의 메시지만 처리한다.

**간단한 액터**

고객, 종업원, 진열장

고객은 파이를 주문

종원원은 진열장에 요청

진열장은 종업원에게 기록하고 파이가 있으면 고객에게 보낸다.

**드러나지 않는 동시성**

공유된 상태가 없이 각자의 행동만 실행한다.

**얼랭이 장을 마련하다**

얼랭에서는 액터를 프로세스로 부름

* 프로세스 생애주기 관리(슈퍼비전)
* 실행중인 시스템 코드를 멈추지 않고 바꾸는 기능 지원(핫코드로딩)

#### 칠판

> 칠판으로 작업 흐름을 조율하라

### 마치며

전역데이터로 동시성 프로그래밍을 하다보면 mutex로 도배가 되면서 추후에 봐도 잘 이해가 가지 않을때가 있다. 액터모델로 구현된 코드들은  코드들이 눈에 확 들어올 뿐 아니라 더 이해하기도 쉬웠었다. 그런 코드를 짜기위해 분투해야겠다. 칠판시스템은 사실 이해가 가지 않는다. '악의마음을읽는자들'의 프로파일러들처럼 각각의 단서들을 칠판위로 올리고 결론을 찾아내는 것 같은데 글로만 봐서는 잘 이해가 안간다😓

